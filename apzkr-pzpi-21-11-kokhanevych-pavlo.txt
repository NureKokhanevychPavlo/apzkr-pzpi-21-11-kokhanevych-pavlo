2

Міністерство освіти і науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії


КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контролю за домашніми тваринами в спеціальному готелі для тварин

Студент гр. ПЗПІ-21-11               __________________ Коханевич П.Г.
(підпис)

Керівник роботи                           ________________ доц. Лещинська І.О.
(підпис)
Роботу захищено «__»_________2024 р.
з оцінкою _________________________

Комісія:                                          ______________ доц. Лещинський В.О.
(підпис)
                                                        ________________ доц. Лещинська І.О.
(підпис)
                                                       _______________ ст. викл. Сокорчук І.П.
(підпис)





Харків
2024 р.

Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	 Навчальна дисципліна Архітектура програмного забезпечення                            

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

                                                Коханевичу Павлу Григоровичу                                      
1. Тема роботи: Програмна система для контролю за домашніми тваринами в спеціальному готелі для тварин	
2. Термін узгодження завдання курсової роботи «18»       березня 	2024 р.
3. Термін здачі студентом закінченої роботи «_08_»	 червня      	2024 р.
4. Вихідні дані до проекту (роботи):  написана пояснювальна записка, реалізована серверна частина, реалізована клієнтська частина, створений мобільний               застосунок, реалізований IoT програмний застосунок.                                             
5. Зміст	пояснювальної записки (перелік питань, що належить розробити) 
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки                
6. Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень)
схема бази даних, діаграма варіантів використання, діаграма розгортання, інтерфейс головної сторінки                                                                                          



КАЛЕНДАРНИЙ ПЛАН





№
Основні етапів курсової роботи
Термін виконання
етапів роботи
Примітка
1
 Функціональна специфікація
 програмного проекту
18.03.2024-05.04.2024

2
 Проектування програмного
 проекту
05.04.2024-10.04.2024

3
 Кодування програмного проекту
10.04.2024-30.05.2024

4
 Оформлення пояснювальної
 записки
01.06.2024-08.06.2024

5
 Захист курсової роботи
08.06.2024-14.06.2024


Дата видачі завдання «18»            березня	2024 р.


Керівник	 	доц. Лещинська І.О.
(підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІ-21-11
	 		Коханевич П.Г.
(підпис)

РЕФЕРАТ

Пояснювальна записка до курсової роботи: 46 с., 10 рис., 0 таблиць, 2 додатка, 5 джерел.
АРХІТЕКТУРА, ГОТЕЛЬ, КІМНАТА, ОРЕНДА, ПРОГРАМА, СИСТЕМА, ТВАРИНА.
Об’єктом розробки є програмна система контролю за тваринами в спеціальному готелі для тварин.
Метою роботи є створення комплексної системи, яка дозволяє автоматизувати процеси управління готелем для тварин, включаючи моніторинг умов утримання, управління бронюванням, контроль за харчуванням, безпекою та комфортом тварин. Це повинно забезпечити високий рівень зручності та безпеки для власників тварин та персоналу готелю.
Методи, застосовані для розробки даної програмної системи, включають використання монолітної архітектури для забезпечення швидкості розробки та зручності підтримки проекту. Розробка на стороні сервера базується на фреймворку Spring Boot, що забезпечує надійну та безпечну внутрішню інфраструктуру. В якості системи управління базами даних обрано MySQL для ефективного зберігання та управління даними про клієнтів, тварин та оренди. Для розробки гнучкого веб-додатку використовується React, а Kotlin застосовується для створення мобільного додатку, що забезпечує безперешкодний доступ до системи. Компонент Інтернету речей, який складається з ESP32, датчика DH22, фотоелектричного резистора та лампи, дозволяє здійснювати моніторинг тварин під час їх перебування в кімнаті.
Результатом виконання курсової роботи стала розробка комплексної системи контролю за тваринами в спеціальному готелі для тварин, що включає серверну частину, компонентів інтернету речей та клієнтські додатків.

ЗМІСТ

Вступ	6
1 Аналіз предметної галузі	8
1.1 Аналіз предметної області	8
1.2  Аналіз існуючих аналогів	8
1.3 Концептуальне моделювання	9
2 Постановка задачі	13
2.1 Основний функціонал системи	13
2.2 Рамки первинного випуску	14
2.3 Припущення та залежності	16
2.4 Робоче середовище	17
3 Структура бази даних	18
4 Опис розробленої програмної системи	20
4.1 Кодування серверної частини	20
4.2 Кодування IoT частини	22
4.3 Кодування мобільної частини	24
4.4 Проектування програмного проекту	27
5 Особливості застусування	29
Висновки	30
Перелік джерел посилання	32
Додаток А Код реалізації основної бізнес-логіки сервера	33
Додадок Б Графічні інтерфейси мобільної частини	44

ВСТУП

Програмна система контролю за домашніми тваринами в спеціальному готелі, вирішує достатньо багато проблем власників та спонукає інших людей до придбання тварин.
Наявність домашніх вихованців стає все більш популярним явище в сучасному світі, яке призводить до зниження кількості безпритульних тварин. Суспільство розглядає їх як невід’ємну частину соціального та сімейного життя, тому не дивно, що домашніх тварин прирівнюють до повноцінного члена родини та готові надавати їм відповідні умови. Нерідко можна побачити заклади харчування та офіси, які передбачають наявність тварин у клієнтах чи співробітниках, тому надають спеціальні приміщення та середовища для них. 
На жаль, існує певний відсоток соціальних закладів, які забороняють вхід для домашніх тварин клієнтів, або може виникнути необхідність короткого візиту певної країни чи місцевості, де можливості взяти своїх тварин буде відсутня. Тварин не цікавлять екскурсії, виснажують довгі піші прогулянки, з ними навряд чи пустять до музеїв і більшості закладів харчування, а у випадку подорожі за кордон кількість складнощів і перепон може збільшитися в рази. Щоб вирішити дану проблему зазвичай шукають людей, які готові подбати про них, але для власників це значний ризик стикнутися із недоброзичливими кадрами. Люди тепер ставляться до своїх улюбленців, як до дітей, — вони шукають більш інтерактивний та індивідуальний досвід для своїх вихованців, а не просто залишають їх на когось. Спеціальні готелі для короткочасного перебування тварин вирішують це питання, оскільки власник сам бронює кімнату та спостерігає за своїми тваринами, тим самим максимально уникає втручання сторонніх осіб. 
 Запропонована програмна система охоплюватиме ряд інструментів та функцій, спеціально розроблених для готелів, які спеціалізуються на догляді за тваринами. Вона дозволить автоматизувати процес обліку, зберігання та редагування даних про користувачів, тварин та оренд у базі даних. Крім того, це полегшить забезпечення безпеки тварин та спокою власників, які зможуть контролювати стан кімнати в будь-який час. Функції управління кормами допоможуть керувати процесом годівлі та оптимізувати ресурси.
Головна ідея полягає в створенні зручного та ефективного інструмента для контролю за тваринами в спеціальному готелі для тварин. Мета продукту  полягає в автоматизації процесу догляду за тваринами у період короткочасного терміну перебування в готелі та максимально уникнути залучення сторонніх людей.
Таким чином це сприяє підвищенню ефективності управління готелями для тварин, забезпечуючи автоматизацію рутинних процесів та покращуючи умови утримання тварин. Це не тільки підвищує рівень задоволеності клієнтів, але й сприяє розвитку індустрії послуг для тварин, роблячи її більш сучасною та технологічною. Автоматизована система дозволяє забезпечити високий рівень зручності та безпеки як для власників тварин, так і для персоналу готелю, створюючи оптимальні умови для догляду за домашніми улюбленцями.

1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ
1.1 Аналіз предметної області

Сучасна індустрія послуг для тварин активно розвивається, включаючи спеціалізовані готелі для домашніх улюбленців. Велика кількість власників тварин, які часто подорожують або мають насичений робочий графік, потребують якісних послуг з догляду за їхніми улюбленцями під час їхньої відсутності. В цьому контексті готелі для тварин стають все більш популярними.
Основні функції таких готелів включають забезпечення комфортних умов проживання, харчування, регулярні прогулянки, ветеринарний догляд, а також організацію дозвілля для тварин. Важливою складовою є забезпечення безпеки та здоров'я тварин, що вимагає постійного моніторингу умов утримання, таких як температура, вологість, рівень шуму та освітлення.
Власники тварин очікують від готелів не тільки якісного догляду, але й можливості дистанційно контролювати стан своїх улюбленців. Це включає доступ до відеоспостереження, отримання регулярних звітів про стан тварини та можливість спілкування з нею через мобільні додатки. З іншого боку, адміністрація готелів зацікавлена у підвищенні ефективності управління, що включає автоматизацію процесів бронювання, ведення обліку та контролю за умовами утримання.

1.2  Аналіз існуючих аналогів

Програмна система контролю за домашніми тваринами в спеціальному готелі, вирішує достатньо багато проблем власників та спонукає інших людей до придбання тварин. До гарних аналогів даної програмної системи можемо віднести готель для котів «murmeow.com.ua».
Даний аналог системи спирається на ідеї створення спеціалізованого готелю для котів та кішок, який надає комфортні умови та дбайливе ставлення до тварин в період відсутності власника. Даний готель має можливості вибрати зручні кімнати для котів, отримувати фото та відео звіти про стан тварини, має спеціальні ігрові майданчики та надає кваліфікований персонал, який подбає про тварин.
Якщо порівнювати аналог із даною системою, то можна твердо стверджувати, що поточна система буде мати більш широкі можливості та зменшить кількість необхідних співробітників для обслуговування, також надасть можливість бачити, годувати та розмовляти із своїм другом в будь-який час віддалено. Наявність автоматизованого механізму оренди та нагляду за твариною, робить поточний продукт кращим за розглянутий аналог, оскільки власник має набагато більше контролю.
Завдяки інтеграції інтернету речей (IoT) технологій, система забезпечує цілодобовий моніторинг параметрів середовища (температура, вологість, освітлення) та автоматичне регулювання умов утримання. Це дозволяє мінімізувати потребу у втручанні персоналу та підвищити рівень безпеки і комфорту тварин.
Таким чином, поточна програмна система не тільки забезпечує більш високий рівень автоматизації та інтеграції, але й пропонує додаткові функції, які роблять її значно більш привабливою для власників тварин у порівнянні з існуючими аналогами. Це включає покращений контроль, гнучкість та зручність використання, що сприяє підвищенню якості послуг у спеціалізованих готелях для тварин.

1.3 Концептуальне моделювання

Предметна область містить три типи користувачів на яких система має спиратися та реалізовувати свою функціональність залежно від потреб таких користувачів як клієнти, тобто власники тварин, адміністратор бази даних та адміністратор, який відповідає за бізнес-логіку системи. Кожен тип користувача має свій набір чітких функціональних потреб до продукту. 
Клієнт або власник тварини є основним типом користувача для даної предметної області, який повинен мати базові функції перегляду інформації та можливості з нею працювати та змінювати. Власник тварини може мати змогу переглянути інформацію про готелі, кімнати, обрати вільні кімнати, переглянути минулі оренди та поточні. Оскільки програмна система повинна мати певні способи монетизації, то клієнт зможе орендувати певну кімнату в певний період, щоб отримати доступ  до панелі контролю кімнати на період оренди. Така функціональність вимагає заповнення форми для надання інформації про тварину, номер картки, термін оренди. Зворотній зв’язок необхідний для користувача, щоб терміново повідомити про певні проблеми з його твариною. Перегляд власних тварин та їх додавання та редагування в системі, необхідна функція, щоб полегшити процес контролю та реєстрації тварини до системи. Кожен клієнт буде мати змогу редагувати свій власний профіль.
Описані функціональні потреби повністю характеризують необхідні функції для власника тварини та представленні у вигляді діаграми прецедентів. 
Функціональні потреби адміністратора бази даних спираються на можливостях роботи бази даних та забезпечення цілісності даних, щоб керувати інформаційним змістом системи та сприяти її захисту. Даний вид адміністраторів має потребу переглядати всю інформацію, яка зберігається в системі про користувачів, тварин, оренди, кімнат та інші сутності, які наявні в системі. 
Оскільки адміністратор повинен не лише спостерігати за наявними даними, а й працювати з ними, тому він матиме потребу редагувати, видаляти, додавати різні види інформації. Бази даних зазвичай мають резервні копії, щоб уникнути ризику втрати інформації, тому функції резервного копіювання та відновлення системи після можливої аварії обов’язково мають бути в наявності даного адміністратора. Для візуалізації описаних функцій адміністратора бази даних було створено діаграму прецедентів для даного типу користувачів (див.рис. 1.1).


Рисунок 1.1 - Діаграма варіантів використання для адміністратора бази даних

Останній вид користувачів це адміністратори бізнес-логіки програмної системи. Функціональні потреби даних адміністраторів спираються на контролі різних видів інформації та формування статистик, щодо роботи програмної системи загалом.  Всі функціональні потреби, які були описані для даного користувача,  представлені у вигляді діаграми прецедентів (див. рис. 1.2). 
Даний вид адміністраторів буде мати можливість формувати статистику заробітку готелю в певний період часу, що дозволяє визначити доцільність витрат та стан певного готелю. Також присутня можливість визначати середню тривалість оренди кімнати, що дозволяє формувати нові бізнес-вимоги.


Рисунок 1.2 - Діаграма варіантів використання для адміністратора бізнес-логіки

Система повинна надавати можливості реєстрації та автентифікації, оскільки дана функціональність характерна для всіх видів користувачів, то було прийняте рішення виділити даний функціонал на окремій діаграмі прецедентів (див. рис. 1.3).


Рисунок 1.3 – Діаграма варіантів використання для неавторизованих користувачів

Під час формування діаграм прецедентів та концептуального аналізу області було виділено основні види користувачів для даної програмної системи та їхній функціонал, який був описаний, а також представлений у вигляді діаграм прецедентів.

2 ПОСТАНОВКА ЗАДАЧІ
2.1 Основний функціонал системи

Виділимо основну функціональність даної системи:
– контроль температури, вологості та світла в кімнаті;
– забезпечення можливості відеоспостереження та спілкування із твариною віддалено;
– повідомлення власнику, якщо рівень звуку в кімнаті занадто високий протягом певного терміну;
– функція спостереження за рівнем наповненості блоків харчування;
– повідомлення про закінчення або про ризик закінчення запасів певного блока;
– можливість задання графіку за яким пристрої будуть надавати їжу тварині;
– автоматичне формування графіку харчування для тварини спираючись на її розмір, вид та термін перебування;
– аналітичний інструмент, який аналізує дані про час і кількість приймання їжі твариною. Вона може надавати звіти власникам про регулярність харчування, спожиту кількість їжі;
– статистика прибутку певного закладу за певний період часу та визначення середнього терміну оренди;
– можливість зареєструвати домашню тварину до системи, щоб при бронюванні не заповнювати інформацію про неї;
– функція реєстрації для мобільної та веб-частини системи;
– пошук, фільтрація даних під час пошуку готелю;
– оренда кімнати на певний період та відразу оплата за неї;
– зворотній зв’язок із адміністрацією;
– функція редагування власного облікового запису;
– власник зможе переглядати історію бронювання кімнат;
– забезпечення локалізації для України та міжнародної англійської локалізації;
– механізм реагування на стан тварини спираючись на відеоспостереження та шум.

2.2 Рамки первинного випуску

Для кращого опису функціональності системи контролю за тваринами в спеціальному готелі для тварин у першому випуску програмного продукту, поділімо функції на частини, включаючи серверну, частину IoT, веб-частину та мобільний додаток.
Розпочнімо із функціональності серверної частини:
– автентифікація та авторизація. Сервер має забезпечити систему автентифікації користувачів та надання прав доступу на основі ролей;
– збереження даних. Сервер повинен забезпечити зберігання даних про користувачів, готелі, тварин, список оренд, інформацію про кожну кімнату;
–  підтвердження оплати. Сервер має містити ключ  певного API та ініціалізувати оплату;
– захист даних. Всі важливі атрибути із бази даних мають бути зашифровані та при необхідності дешифровані на серверній частині;
–  статистики. Сервер повинен містити логіку та правильно формувати статистику прибутку певного закладу за певний період часу та визначення середнього терміну оренди;
– автоматичне формування графіку харчування. Якщо при оренді кімнати не буде вказаний бажаний графік харчування, то сервер буде сам вираховувати найкращий графік спираючись на час перебування, розмір тварини та кількість їжі;
– адміністрування. Сервер повинен враховувати наявність ролей, які зможуть мати широкий доступ до даних.
Тепер розглянемо функціональність для IoT частини:
–  повинно бути забезпечено збір даних про температуру, звук, вологість та яскравість світла;
– моніторинг та контроль температури та звуку, а саме аналіз даних про температуру протягом 24 годин, якщо протягом даного часу поточна температура буде відхилятися від бажаної на 3-5 градусів чи звук буде перевищувати норму протягом 5 хвилин, то він терміново надсилає адміністраторам та власникам повідомлення про проблему;
– контроль світла в приміщенні. Світло зможе автоматично регулюватися залежно від періоду дня;
– відеоспостереження. Пристрій має надати доступ для спостереження за твариною для користувача; 
– передача даних. Пристрої повинні мати можливість передавати зібрані дані на сервер для подальших дій;
– аналітичний інструмент, який аналізує дані про час і кількість приймання їжі твариною.
Перейдемо до клієнтської частини, а саме веб-частини:
– графічний інтерфейс для авторизації та реєстрації: Дана частина повинна надати користувачам можливість авторизуватися в системі та створювати облікові записи використовуючи зручні графічні інтерфейси;
– наявність окремих видів інтерфейсів для різних адміністраторів. Тобто адміністратори під час входження до системи повинні мати різні інтерфейси порівняно з користувачами та мати можливість проводити операції лише ті, які передбаченні даної системою та блокувати можливості, які не були передбачення для певного виду користувача;
– локалізація. Відображення мови та стилів написання залежно від країни та мови;
– перегляд статистики та історії: Адміністратори можуть переглядати статистику прибутку певного закладу за певний період часу та визначення середнього терміну оренди, а клієнти можуть проглянути історію користування, наявні готелі та вільні кімнати маючи зручні засоби сортування та фільтрування інформації;
– оплата онлайн. Можливість здійснити платіж за оренду кімнати для тварини виключно онлайн використовуючи графічний інтерфейс та дані кредитної картки;
– наявність налаштувань власного кабінету. Можливість змінювати персональну інформацію;
– наявність доступу перегляду інформації про готелі та адреси, кімнати і таке інше;
– доступ до контролю кімнати тварини під час оренди. Можливість змінювати певні характеристики кімнати такі як: температуру, світло, вологість, графік харчування.
Мобільний додаток буде мати більшість функцій, які має веб-частина, але кілька додаткових, а саме: 
– зворотній зв’язок. Можливість надіслати повідомлення адміністраторам про певну проблему на пошту для подальшого опрацювання певним працівником;
– спілкування через камеру. Можливість спілкуватися із твариною використовуючи камеру та мікрофон.

2.3 Припущення та залежності

Почнімо із визначення основних припущень:
– сервера мають достатню потужність, що впоратися із потоком користувачів близько кількох десятків тисяч;
– користувач буде мати інтернет та пристрої для того, щоб користуватися системою;
– власник має самостійно помістити тварину до кімнати під час оренди;
– готель має всі необхідні корма для тварин, які зазначенні в системі;
– готель забезпечує належний догляд та безпеку тварин під час їхнього перебування;
– користувачі дотримуються правил та інструкцій, наданих готелем для користування системою.
Тепер виділимо залежності, які виникають під час використання системи:
– кількість користувачів буде прямопропорційно залежати від обсягу компаній та їхніх співробітників, які придбали дану систему;
– доступ до функції кімнати буде залежати від наявності сплати користувача, щодо оренди даного приміщення;
– температурний режим залежить від налаштувань конкретної кімнати;
– проведення інвентаризації буде залежати від статистики початку та кінця часу користування холодильником протягом дня. 

2.4 Робоче середовище

Серверна частина буде побудована з використанням фреймворку Spring Boot [1], Stripe API, JUnit, Hibernate та програмуванням на мові Java. Дані програмної системи будуть зберігатися в базі даних та контролюватися системою управління базою даних MySQL. Для розробки серверної частини буде використовуватися IntelliJ IDEA Community Edition.
У веб-частині для створення користувацького інтерфейсу будуть використані JavaScript, HTML та CSS, а також фреймворк React для поліпшення роботи. Для розробки веб-частини частини буде використовуватися Visual Studio Code. Для мобільної частини передбачено використання мови програмування Kotlin та інструмент для впровадження залежностей Hilt, інструмент для асинхронного програмування Coroutines. Для взаємодії із серверною частиною буде застосовна бібліотека Retrofit. Для розробки мобільної частини буде використовуватися Android Studio [2].
Інтернет речей (IoT) застосунок, буде розроблений з використанням платформи Wokwi, щоб отримати велику гнучкість та надійність під час симуляції процесу роботи. Сенсори будуть температурні, вологості, відеокамера, світлові. Для комунікації з підключеними частинами програмної системи  буде використовуватися REST API.

3 СТРУКТУРА БАЗИ ДАНИХ

Спираючись на моделювання предметної області була побудована ER- діаграма бази даних, яка враховує зберігання інформації для всієї представленої функціональності.
Спочатку було виділено основні стрижневі сутності, а саме: користувачі, тварини, готель, графік харчування. Потім для уникнення  зв’язків багато до багатьох були створенні проміжні та додаткові сутності для  повноцінного охоплення бізнес-логіки програми. Тобто було додано сутності  такі як кімната, оренда, кількість харчування.
Далі були визначені переліки атрибутів, що повинні мати сутності:
– користувач: користувач_id, пароль, електронна пошта, ПІБ, рік народження, вид користувача, номер телефону, посилання на фото. Первинний ключ: користувач_id ;
– тварина:  тварина_id, кличка, вік, вага, вид, опис, посилання на фото. Первинний ключ: тварина_id;
– готель: готель_id, назва, область, район, місто, вулиця, номер будинку. Первинний ключ: готель_id;
– кімната: кімната_id, номер, площа, ціна за 1 годину, IP, порт. Первинний ключ: кімната_id;
– оренда: оренда_id, початок оренди, кінець оренди. Первинний ключ: оренда_id;
– кількість харчування: харчування_id, порція, тип їжі. Первинний ключ: харчування_id;
– графік харчування: графік_id, дата та час. Первинний ключ: графік_id.
Після виділення атрибутів для сутностей були позначенні зв’язки між ними враховуючи функціональні потреби користувачів системи:
– "користувач - тварина". Він має тип зв’язку “один до багатьох”, оскільки користувач може мати багато тварин, а тварина має лише одного власника;
– "готель - кімната". Він має тип зв’язку “один до багатьох”, оскільки готель може мати багато кімнат, а кімната належить одному готелю;
– "тварина - оренда". Він має тип зв’язку “один до багатьох”, оскільки тварина може мати багато оренд, а оренда кімнати може містити лише одну тварину;
– "кімната - оренда". Він має тип зв’язку “один до багатьох”, оскільки кімната може мати багато оренд, а оренда кімнати може містити лише одну кімнату;
– "оренда – кількість харчування". Він має тип зв’язку “один до багатьох”, оскільки оренда може мати багато видів харчування, а кількість харчування кімнати може належати лише одній оренді;
– "кількість харчування – графік харчування". Він має тип зв’язку “один до багатьох”, оскільки кількість належати багатьом графікам, а графік може належати лише одній кількості харчування.
Визначивши сутності, атрибути між ними була побудована ER-діаграма реляційної бази даних (див. рис. 3.1).


Рисунок 3.1 – Схема бази даних

4 ОПИС РОЗРОБЛЕНОЇ ПРОГРАМНОЇ СИСТЕМИ
4.1 Кодування серверної частини

 Поточна система включає в себе серверну частину, яка містить основну бізнес-логіку, яка пов’язана із математичними операціями визначення графіку харчування, валідації даних, обробка різних типів помилок, взаємозв’язок із зовнішніми API та методи для обробки та зберігання даних в незалежній базі даних, а також API, щоб інші компоненти змогли взаємодіяти з нею. Сервер використовує контролери для отримання різних типів інформації та її обробку. Серверна частина забезпечує контроль доступу для кількох типів користувачів, а також  для IoT частин. Також проводиться резервування даних кожного дня для уникнення ризику втрати даних.
Серверна частина була побудована згідно монолітної архітектури. Даний підхід до розробки програмного забезпечення називається монолітним, тому що весь додаток побудований як єдиний блок. Основна ідея полягає в тому, що всі компоненти програми, такі як інтерфейс користувача, бізнес-логіка та доступ до даних, розгортаються як один цілісний модуль. Вибір даного виду архітектури був викликаний особливостями проекту, оскільки в монолітній архітектурі немає необхідності в налаштуванні та керуванні різними сервісами, що дозволяє швидше розробляти та налаштовувати програму. 
Спираючись на широку практику побудови серверних частин, яка полягає у розбитті програми на кілька шарів, які відповідають за свою логіку, то розроблена серверна частина також містить декілька шарів: представлення, бізнес-логіка, шар доступу до даних, безпека. 
Шар представлення містить контролери, вони обробляють HTTP-запити від клієнтських частин, визначаючи шляхи та викликають відповідні сервіси для обробки запитів. Вони надають точку доступу для взаємодії із системою та містять доступ до основної функціональності системи, яка була реалізована. Для кожного типу користувачів передбачений власний контролер такий як: AuthenticationController, BusinesAdminController, DatabaseAdminController, UserController, DeviceController, PaymentController.
Сервіси містять бізнес-логіку системи. Вони виконують обчислення, валідацію та реалізацію об’єктів для комунікації між сервером, обробляючи запити від контролерів. Саме на цьому рівні відбувається зв’язок із зовнішніми API, такі як: Stripe API, Email API,  Dropbox API. Stripe API - це програмний інтерфейс, який надається компанією Stripe для взаємодії з їх платіжною системою. За допомогою Dropbox API  можна створювати різноманітні додатки, що потребують зберігання та обміну даними у хмарі. Даний API  використовується для зберігання фотографій користувачів та тварин. Код наведений в додатку А.
Логіка реалізації процесу створення резервних копій для бази даних також знаходиться в шарі бізнес-логіки. Потрібно виділити, що інтерфейси сервісів та об’єкти для транспортування знаходяться на лінії під назвою “Domain”. Вона містить в собі всі необхідні деталі, щоб дозволити контролерам працювати, використовуючи інжекцію залежностей. Тобто контролери нічого не знають про конкретну реалізацію бізнес-логіки, а лише про задекларовані методи в інтерфейсах та об’єкти для передачі даних. Така структура дозволяє легко розширювати реалізації та змінювати зовнішні API. Щоб зменшити залежності від шару доступу до даних, був використаний механізм “Mapper”, який дозволив перетворювати сутності до об’єктів передачі даних і навпаки.
 Шар доступу до бази даних містить репозиторії та моделі. Репозиторії взаємодіють з базою даних та моделями, забезпечуючи доступ до даних та виконуючи операції, які пов’язані із видаленням, редагуванням, додаванням та зберіганням даних. Окрім стандартних методів репозиторію були створені додаткові запити, які формують спеціальний набір інформації для певного виду користувачів. Також додаткові методи для формування статистик. Для зменшення ризику виникнення помилок в частині, яка стосується роботи із базою даних були використані технології Java Persistence API (JPA) та Hibernate. Це технології , які використовуються для роботи з реляційними базами даних в Java-додатках. JPA є специфікацією для управління об'єктно-реляційною моделлю даних. Вона надає стандартний спосіб відображати Java-об'єкти на таблиці бази даних і навпаки. Hibernate є конкретною реалізацією специфікації JPA, також він є потужним фреймворком Object-Relational Mapping (ORM), який надає додаткові можливості порівняно з базовою специфікацією JPA. 
Моделі містять перелік об’єктів, які мають поля та методи для роботи із сутностями із бази даних.
Шар безпеки містить налаштування для фільтрації користувачів,  використовуючи Spring Security. Дана частина також містить файли конфігурації, які дозволяють правильно налаштувати роботу та перелік фільтрів, що забезпечить доступ для користувачів лише до певних контролерів. Також реалізований перехоплювач помилок. 
Файли фільтрів мають в собі логіку надання дозволу для запиту залежно від його адресу, а також вони визначають послідовність перевірок, які будуть здійснені для кожного запита. Автентифікація відбувається за допомогою токенів java web token (JWT), які формує сервер після авторизації в системі. Авторизація пристрою відбувається за допомогою API  ключа, який повинен міститися в запиті.

4.2 Кодування IoT частини

Інтернет речей (IoT) надав широкі можливості для автоматизації та покращення управління різними системами, зокрема в галузі догляду за тваринами.  Розділ розглядає реалізацію IoT частини для програмної системи контролю за тваринами в спеціальному готелі для тварин. 
Використовуючи платформу Wokwi, був створений прототип, що дозволяє здійснювати моніторинг умов утримання тварин та передавати ці дані на сервер для подальшої обробки.  Платформа Wokwi дозволила швидко та зручно моделювати та тестувати IoT пристрої. Вона забезпечує віртуальне середовище для програмування та налагодження мікроконтролерів та їх периферій. Основними компонентами IoT частини є мікроконтролер ESP32 [3], сенсори DHT22 для вимірювання температури та вологості, фотоелектричний резистор для вимірювання освітленості. Усі ці компоненти об'єднані в єдину систему, що дозволяє збирати та передавати дані про умови утримання тварин на сервері.
ESP32 - центральний вузол системи, який керує всіма сенсорами та здійснює обробку даних. DHT22 - сенсор для вимірювання температури та вологості. Фотоелектричний резистор - сенсор для вимірювання рівня освітленості. Світлодіод та резистор - додаткові компоненти для індикації стану системи. WiFi-з'єднання - забезпечує передачу даних на сервер через бездротову мережу.
Програмне забезпечення для ESP32 написано мовою C++ з використанням бібліотек для роботи з WiFi, HTTP, DHT22 та файлами для передачі файлів.
Основна логіка програми зосереджена у функції loop(), яка виконується безперервно. Спочатку пристрій перевіряє статус підключення до WiFi, і якщо з'єднання присутнє, починає зчитувати дані з датчиків. Для зчитування температури та вологості використовується бібліотека DHTesp, яка дозволяє легко отримувати дані з датчика DHT22, підключеного до піна 15. Рівень освітленості визначається шляхом зчитування аналогового сигналу з фотоелектричного резистора, підключеного до піна 34.
Отримані дані з датчиків перевіряються на коректність. Якщо дані з датчика температури або вологості виявляються некоректними, програма виводить повідомлення про помилку і робить паузу перед наступною спробою зчитування. Якщо всі дані отримані успішно, вони упаковуються у JSON-об'єкт за допомогою бібліотеки ArduinoJson. Створений JSON-об'єкт містить три ключі: temperature, humidity та brightness, що відповідають зчитаним значенням.
Після формування JSON-об'єкта програма налаштовує HTTP-з'єднання з сервером. Використовуючи бібліотеку HTTPClient, здійснюється POST-запит до сервера за вказаною URL-адресою. До заголовка запиту додаються необхідні поля, зокрема Content-Type з типом "application/json" та X-API-Key з API-ключем для автентифікації на сервері. JSON-об'єкт серіалізується у рядок і відправляється на сервер.
Після відправлення запиту програма отримує код відповіді від сервера. Якщо код відповіді вказує на успішне виконання запиту пристрій виводить код відповіді на серійний монітор, що дозволяє користувачу бачити статус операції. Якщо виникає помилка, виводиться відповідний код помилки. Після завершення запиту HTTP-з'єднання закривається.
Цей цикл повторюється кожну хвилину, забезпечуючи постійний моніторинг умов у приміщенні, де перебуває тварина, та регулярне оновлення даних на сервері.

4.3 Кодування мобільної частини

Мобільний додаток містить функціонал, який призначений для звичайного клієнта даної програмної системи. Враховуючи обмежені ресурси мобільних пристроїв, було прийнято рішення використовувати виключно технології, які були створенні для мобільних телефонів, щоб краще керувати ресурсами.
Для створення даного додатку було використано середовище розробки Android Studio та мова програмування Kotlin для забезпечення її широкої функціональності.  Для полегшення безперешкодної комунікації з серверною частиною ми включили бібліотеку Retrofit, що дозволяє без зусиль надсилати та отримувати запити від сервера за специфікацією REST API.
З точки зору безпеки та зручності користувача, додаток використовує токен авторизації, згенерований JWT, який надійно зберігається в загальних налаштуваннях на пристрої користувача. Такий підхід гарантує безпечне та надійне зберігання важливої інформації про авторизацію, що підвищує загальну безпеку додатку.
Мобільний додаток використовує технології для забезпечення зменшення залежностей між класами та шарами програми, а саме Hilt. Це бібліотека для впровадження залежностей в додатках, розроблена Google. Hilt забезпечує простіший та структурований підхід до управління залежностями, використовуючи на основі Dagger 2. Ця бібліотека інтегрується з компонентами Android і сприяє кращому управлінню життєвим циклом об'єктів. Його реалізація вимагала створення окремої файлової структури для створення модулів, які містять логіку ініціалізації об’єктів при їх використанні в програмі. Використання даної технології дозволило зменшити необхідність слідкувати та контролювати залежності під час написання коду.
У даному мобільному додатку було використано Kotlin Coroutines для ефективного управління асинхронними операціями. Вони забезпечують спрощену і більш читабельну обробку асинхронних завдань у порівнянні з традиційними підходами, такими як RxJava. Вони дозволяють писати код асинхронно, який виглядає як синхронний, значно зменшуючи обсяг шаблонного коду і ризик помилок. Завдяки структурі Coroutines, код виглядає чистіше і його легше підтримувати.
 Користувацький інтерфейс визначається за допомогою XML-файлів, що забезпечує чітку структурованість та легкість підтримки. Використання таких типів файлів для опису  дозволяє відокремити логіку програми від візуального представлення, що сприяє кращій організації коду та полегшує внесення змін до дизайну без необхідності модифікації програмного коду. Вони зберігаються в директорії “res/layout”. Кожен XML-файл відповідає за дизайн одного екрану або частини екрану.
Програмне забезпечення складається із трьох логічних архітектурних шарів [4], які забезпечують можливість масштабувати та підтримувати його функціональність без втрати великої кількості часу. Чиста архітектура є однією з ключових архітектурних парадигм, яка була використана у мобільному додатку. Вона забезпечує чітке розділення відповідальностей між різними частинами програми, що сприяє легкості тестування, розширюваності та підтримки коду [5]. В проекті реалізовано три основні шари: модель, домен та інтерфейс користувача.
Шар моделі відповідає за доступ до даних та їхню обробку. Він включає класи, які взаємодіють з базами даних, мережевими сервісами та іншими джерелами даних. Основною метою цього шару є ізоляція джерел даних від решти програми, що забезпечує більшу гнучкість та зменшує зв'язність між компонентами. Для даного проекту він містить основні об’єкти та класи для взаємодії із серверною частиною. Він складається із сутностей, які створенні для зберігання інформації із сервера та формуванню об’єктів для передачі даних. Також наявні репозиторії, які виконують операції із даними та містять конкретну реалізацію логіки обробки. Його репозиторії залежать від абстракцій, які реалізовані в шарі домен.
Шар домену є серцем додатку і містить бізнес-логіку. Він незалежний від конкретних реалізацій джерел даних або способів представлення даних, що робить його більш тестованим та стабільним до змін. Взаємодія між шаром домену та іншими шарами відбувається через інтерфейси. Шар домену не знає про конкретні реалізації джерел даних, що дозволяє легко змінювати або розширювати їх без впливу на бізнес-логіку. В даному додатку цей шар містить інтерфейси, які визначають основну логіку репозиторіїв та додатку. Також присутні об’єкти для передачі даних, які зменшують залежність для інших шарів даної програми. Існує окрема структура файлів для визначення певних випадків користування для шару відображення даних. Тобто кожна функціональна можливість системи містить свій клас для забезпечення контролю між потоками.
Шар інтерфейсу користувача відповідає за відображення даних і взаємодію з користувачем. Він включає Activity, Fragment, ViewModel та інші компоненти, які забезпечують користувацький досвід. Даний шар взаємодіє із шаром доменом для отримання необхідної функціональності та даних, щоб максимально зменшити залежність від шару доступу до даних. Саме тут відбувається логіка, яка відповідає за відображення графічних елементів та їх взаємодія один із одним. Навігація між компонентами даного шару відбувається за допомогою спеціального графа, який містить всю інформацію про їхню наявність та  можливу взаємодію.
Для покращення чистоти коду був використаний шаблон проектування Model-View-ViewModel (MVVM). Цей шаблон дозволяє чітко розділити відповідальності між різними компонентами, що сприяє кращій організації коду. ViewModel є мостом між View та Model. Він отримує дані з Model через доменний шар і підготовлює їх для відображення у View. ViewModel також обробляє події від View, керуючи бізнес-логікою, яка не залежить від специфічного відображення. Використання ViewModel дозволяє зменшити залежність між View та Model, роблячи код більш модульним та легшим для тестування.

4.4 Проектування програмного проекту

Діаграма розгортання створюється із метою описати структуру та взаємозв'язки компонентів програмної системи для контролю за тваринами у спеціальному готелі для тварин. Вона також відображає фізичну архітектуру системи, включаючи розташування апаратних та програмних ресурсів.
Враховуючи поточні вимоги до системи, то діаграма (див. рис. 4.1) містить чотири основні компоненти, які при взаємодії один із одним формують програмну систему.


Рисунок 4.1 – Діаграма розгортання

Основним фізичним компонентом системи потрібно виділити сервер на якому буде відбуватися бізнес-логіка та виконуватися складні обчислення.
Сервер є центральним елементом програмної системи для контролю за тваринами у готелі. Фізично він має розміщуватися на потужному сервері з високими характеристиками продуктивності та надійності. Сервер виконує функції зберігання, обробки та управління даними, обчислення графіків харчування та перевірку даних про тварин і їх власників. 
Використовуючи TCP/IP, він спілкується із базою даних, яка знаходиться на незалежному фізичному пристрої, який містить систему управління базами даних MySQL.  База даних використовується для зберігання інформації про тварин, господарів, оренду, адреса та графіки харчування.
Мобільний додаток є одним з ключових компонентів програмної системи і розглядається як клієнтська частина. Фізично додаток розгортається на мобільних пристроях кінцевих користувачів. Додаток доступний на платформі Android та містить гнучку архітектуру, яка складається із шарів: представлення, абстракції та взаємодії із серверною частиною. Коли користувач взаємодіє із додатком, то він працює із  представлення, яке підтримує логіку роботи графічних елементів. Потім він взаємодіє із шаром доступу до даних, який надсилає серверу запит за допомогою API, отримуючи та відправляючи дані для обробки. Формат даних для  відправлення JSON, а протокол HTTP.
Веб-додаток є важливою частиною програмної системи, яка забезпечує інтерфейс для взаємодії із системою для адміністраторів готелю для тварин. Фізично веб-додаток розгортається на веб-сервері та доступний через веб-браузер. Даний веб-сервер використовує фреймворк React, який дозволяє реалізувати графічні елементи для користувача, а також зв’язок із сервером.
Інтернет речей (IoT) пристрій є однією із частин програмної системи для контролю за тваринами у готелі. Фізично IoT пристрої встановлюються безпосередньо у приміщеннях готелю та забезпечують збір даних про тварин у реальному часі. Пристрій має можливість бездротового зв'язку з сервером мережею Інтернет для передачі зібраних даних, тому буде використовуватися також формат передачі даних JSON та протокол HTTP.

5 ОСОБЛИВОСТІ ЗАСТОСУВАННЯ

Однією з ключових особливостей використання IoT-пристроїв є необхідність забезпечення стабільної та безперебійної комунікації.
Крім того, необхідно враховувати питання енергоефективності та автономності IoT-пристроїв. Оптимізація споживання енергії та забезпечення тривалого часу роботи від батареї є критичними для багатьох сценаріїв використання. Це може включати використання енергоефективних компонентів, оптимізацію програмного забезпечення та регулярне оновлення прошивки для покращення продуктивності та безпеки.
Важливим аспектом успішного використання проекту є забезпечення ефективної взаємодії між мобільним додатком, серверною частиною та IoT-пристроями. Це досягається за рахунок чітко визначених API, які дозволяють легко інтегрувати різні компоненти системи та забезпечувати їхню сумісність. Потрібно враховувати, що без сервера система не зможе працювати навіть на мінімальному рівні, тому забезпечення його роботи доволі важливий момент при розгортанні системи. 
Функціональність мобільного пристрою вимагає наявності інтернету для здійснення комунікації між сервером та обов’язкової авторизації. Даний додаток буде працювати лише на мобільних пристроях, які містять операційну систему Android та потребує певних дозволів від користувача під час завантаження.
Обліковий запис користувача починається із головної сторінки (див. рис. Б.5.1), де знаходиться основний набір інформації. Перелік поточних оренд (див. рис. Б.5.2) дозволяє переглянути список дозволів до кімнати та керувати ними при необхідності. Наявність списку поточних оренд вимагає, щоб поточний час збігався із терміном початку оренди, лише після цього функціонал буде доступний. Основна сторінка також дозволяє переглянути історію оренд (див. рис. Б.5.3)  та список доступних домашніх тварин (див. рис. Б.5.4). Зворотній зв’язок забезпечує можливість відправки повідомлення до служби підтримки (див. рис. Б.5.5).  

ВИСНОВКИ

У даній роботі було розроблено комплексну систему, яка включає мобільний додаток, серверну частину та IoT-компоненти. Ця розробка базується на сучасних архітектурних підходах і технологіях, що забезпечує високу продуктивність, надійність та гнучкість системи. Основною метою проекту було створення інтегрованого рішення, яке дозволяє забезпечити ефективний і зручний користувацький досвід при взаємодії з системою, а також вирішення проблеми власників тварин, що покращить тенденцію зростання кількості домашніх тварин у світі.
Перед розробкою вимог до програми ми провели дослідження аналогічних продуктів, щоб отримати розуміння предметної області. На основі результатів, отриманих під час концептуального моделювання предметної області, ми створили базу даних з сутностями, адаптованими до специфічних потреб управління тварин. 
Серверна частина була розроблена на основі бізнес-вимог та бази даних, щоб проводити обчислення та надавати змогу іншим компонентам системи взаємодіяти із нею.
Було створено мобільний додаток з інтуїтивним інтерфейсом, який забезпечує користувачам легкий доступ до функцій системи. Додаток підтримує інтеграцію з серверною частиною та IoT-пристроями, що дозволяє користувачам отримувати актуальну інформацію та керувати пристроями в реальному часі. Додаток враховує загальні принципи та підходи для написання масштабованих та гнучких програм, що дозволяє легко вносити зміни без втрати часу.
IoT-додаток системи включають різноманітні сенсори та контролери, які забезпечують збір даних та виконання завдань у реальному часі. Це дозволяє надавати можливість контролювати певні аспекти та умови проживання тварини під час оренди.
Перш за все, така система дозволяє власникам тварин віддалено контролювати та відстежувати благополуччя своїх улюбленців через мобільні додатки або веб-інтерфейси. Це забезпечує їм спокій, знаючи, що їх тварини отримують належну ​​опіку і увагу. Вона має базовий функціонал для користувача, такий як: авторизація, реєстрація, оренда та вибір готелю і кімнати, можливість звернутися до адміністраторів готелю, також клієнт зможе керувати власним персональним кабінетом та кімнатою для тварин.
Для власників готелю ця система створює зручну логіку управління та моніторингу. Вони можуть ефективно відстежувати розміщення та харчування тварин, а також спілкуватися з власниками через вбудовані засоби зв'язку. Також власники можуть зменшити кількість людського персоналу для підтримки функціональностей готелів. 
У результаті розробка програмної системи для контролю за тваринами у спеціальному готелі створила продукт [6], який надає позитивні враження як для власників, так і для персоналу, роблячи процес управління та догляду за тваринами більш зручним та ефективним.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1. Spring boot. Spring Boot. URL: https://spring.io/projects/spring-boot (date of access: 05.06.2024).
2. Develop for android | android developers. Android Developers. URL: https://developer.android.com/develop (date of access: 05.06.2024).
3. ESP-IDF Programming Guide - ESP32 - – ESP-IDF Programming Guide v5.2.2 documentation. Technical Documents | Espressif Systems. URL: https://docs.espressif.com/projects/esp-idf/en/stable/esp32/index.html (date of access: 05.06.2024).
4. Martin R. Clean architecture: a craftsman's guide to software structure and design. Pearson Education, Limited, 2017.
5. Martin R. Robert C. martin clean code collection (collection). Pearson Education, Limited.
6. Павло Коханевич. Опис та тестування програмної системи, 2024. YouTube. URL: https://www.youtube.com/watch?v=DqBGjNX62rc (дата звернення: 15.06.2024).

ДОДАТОК А
Код реалізації основної бізнес-логіки сервера

UserServiceImpl.java
1. @Service
2. public class UserServiceImpl implements UserService {
3.
4.     @Autowired
5.     private UserRepository userRepository;
6.
7.     @Autowired
8.     private ScheduleRepository scheduleRepository;
9.
10.     @Autowired
11.     private RoomRepository roomRepository;
12.
13.     @Autowired
14.     private HotelRepository hotelRepository;
15.
16.     @Autowired
17.     private PetRepository petRepository;
18.
19.     @Autowired
20.     private Mapper mapper;
21.
22.     @Override
23.     @Async
24.     public UserDto getUserById(Integer userId) {
25.         if (userRepository.existsById(userId)) {
26.             return mapper.map(userRepository.findById(userId), UserDto.class);
27.         } else {
28.             return null;
29.         }
30.     }
31.
32.     @Override
33.     @Async
34.     public boolean saveUser(UserDto user, MultipartFile file) {
35.         if (user == null) return false;
36.         if (!Validation.isPasswordCorrect(user.getPasswordHash())) return false;
37.
38.         if (!userRepository.existsById(user.getUserId())) {
39.             BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
40.             user.setPasswordHash(passwordEncoder.encode(user.getPasswordHash()));
41.         }
42.
43.         if (file != null) {
44.             PhotoParser photoParser = new PhotoParser(file);
45.             photoParser.savePhoto();
46.             user.setPhotoLink(photoParser.getDropboxFilePath());
47.         }
48.
49.         userRepository.save(mapper.map(user, UserEntity.class));
50.         return true;
51.     }
52.
53.     @Override
54.     @Async
55.     public byte[] getUserPhoto(int userId) {
56.         if (userRepository.findById(userId).isPresent()) {
57.             return PhotoParser.pullPhoto(userRepository.findById(userId).get().getPhotoLink());
58.         }
59.         return null;
60.     }
61.
62.     @Override
63.     @Async
64.     public boolean deleteUser(int userId) {
65.         if (userRepository.existsById(userId)) {
66.             userRepository.deleteById(userId);
67.             return true;
68.         }
69.         return false;
70.     }
71.
72.     @Override
73.     @Async
74.     public UserDto findUserByEmail(String email) {
75.         if (email == null || email.isEmpty()) return null;
76.
77.         return mapper.map(userRepository.findUserByEmail(email), UserDto.class);
78.     }
79.
80.     @Override
81.     @Async
82.     public List<PetDto> getListOfPets(int userId) {
83.         if (userRepository.existsById(userId) && petRepository.getPetsByUserId(userId).isPresent()) {
84.             return mapper.map(petRepository.getPetsByUserId(userId).get(), PetDto.class);
85.         }
86.         return null;
87.     }
88.
89.     @Override
90.     @Async
91.     public boolean addPets(List<PetDto> pets) {
92.         if (!pets.isEmpty()) {
93.             petRepository.saveAll(mapper.map(pets, PetEntity.class));
94.             return true;
95.         }
96.         return false;
97.     }
98.
99.     @Override
100.     @Async
101.     public List<HistoryRentingResponse> getHistoryRenting(int userId) {
102.         if (userRepository.existsById(userId) && userRepository.getHistoryOfRentingByUserId(userId).isPresent()) {
103.            return mapper.map(userRepository.getHistoryOfRentingByUserId(userId).get(), HistoryRentingResponse.class);
104.         }
105.         return null;
106.     }
107.
108.     @Override
109.     @Async
110.     public List<HotelDto> getAllHotels() {
111.         return mapper.map(hotelRepository.findAll(), HotelDto.class);
112.     }
113.
114.     @Override
115.     @Async
116.     public List<RoomDto> getAllRoomsByHotel(int hotelId) {
117.         if (hotelRepository.existsById(hotelId) && roomRepository.getAllRoomsByHotelId(hotelId).isPresent()) {
118.             return mapper.map(roomRepository.getAllRoomsByHotelId(hotelId).get(), RoomDto.class);
119.         }
120.         return null;
121.     }
122.
123.     @Override
124.     @Async
125.     public boolean addNewRentingForUser(List<ScheduleDto> scheduleDtoList) {
126.         try {
127.             if (isRentingListValid(scheduleDtoList)) {
128.                 scheduleRepository.saveAll(mapper.map(scheduleDtoList, ScheduleEntity.class));
129.                 return true;
130.             }
131.         } catch (Exception e) {
132.             e.printStackTrace();
133.         }
134.
135.         return false;
136.     }
137.
138.     @Async
139.     private boolean isRentingListValid(List<ScheduleDto> scheduleDtos) {
140.         ScheduleDto scheduleDto;
141.         for (ScheduleDto dto : scheduleDtos) {
142.             scheduleDto = dto;
143.             if (scheduleDtos.isEmpty() || !scheduleDto.getDateTime().isAfter(LocalDateTime.now()) ||
144.                     !scheduleDto.getDietDto().getRentDto().getBeginDate().isAfter(LocalDateTime.now()) ||
145.                     !scheduleDto.getDietDto().getRentDto().getEndDate().isAfter(scheduleDto.getDietDto().getRentDto().getBeginDate())) {
146.                 return false;
147.             }
148.         }
149.         return true;
150.     }
151.
152.     @Override
153.     @Async
154.     public List<RoomDto> getAllFreeRoomByPeriod(int hotelId, LocalDateTime beginDate, LocalDateTime endDate) {
155.         if (hotelRepository.existsById(hotelId) && beginDate.isAfter(LocalDateTime.now()) && endDate.isAfter(LocalDateTime.now()) &&
156.                 roomRepository.getAllFreeRoomByPeriod(hotelId, beginDate, endDate).isPresent()) {
157.             return mapper.map(roomRepository.getAllFreeRoomByPeriod(hotelId, beginDate, endDate).get(), RoomDto.class);
158.         }
159.         return null;
160.     }
161.
162.     @Override
163.     @Async
164.     public boolean sendMessageToAdmin(int userId, String message) {
165.         if (userRepository.existsById(userId)) {
166.             UserEntity userBusinessAdmin = userRepository.findAll().stream().filter(userEntity -> userEntity.getTypeUser().toString().equals(UserType.BUSINESS_ADMIN.toString())).toList().get(0);
167.             EmailSender emailSender = new EmailSender();
168.             emailSender.sendEmail(userBusinessAdmin.getEmail(), message);
169.             return true;
170.         }
171.
172.         return false;
173.     }
174.
175.     @Override
176.     @Async
177.     public RoomDto getRoomById(int roomId) {
178.         if (roomRepository.existsById(roomId)) {
179.             return mapper.map(roomRepository.findById(roomId), RoomDto.class);
180.         }
181.         return null;
182.     }
183. }


AuthenticationServiceImpl.java
1. @Service
2. public class AuthenticationServiceImpl implements AuthenticationService {
3.
4.     @Autowired
5.     private CustomUserDetailsServiceImpl customUserDetailsServiceImpl;
6.
7.     @Autowired
8.     private AuthenticationManager authenticationManager;
9.
10.     /**
11.      * 24 hours in milliseconds
12.      */
13.     private static final long TOKEN_EXPIRATION_TIME = 1000 * 60 * 24;
14.
15.     /**
16.      * 7 days in milliseconds
17.      */
18.     private static final long REFRESH_TOKEN_EXPIRATION_TIME = 604800000;
19.
20.     private final static String SECRET_KEY = "413F442847284862506553685660597033733676397924422645294848406351";
21.
22.
23.     @Override
24.     @Async
25.     public JwtAuthenticationResponse signIn(SignInRequest signInRequest) {
26.         if (signInRequest == null) return null;
27.         if (!Validation.isEmailCorrect(signInRequest.getEmail()) ||
28.                 !Validation.isPasswordCorrect(signInRequest.getPassword()))  return null;
29.
30.         authenticationManager.authenticate(new UsernamePasswordAuthenticationToken(
31.                 signInRequest.getEmail(),
32.                 signInRequest.getPassword())
33.         );
34.
35.         var user = customUserDetailsServiceImpl.loadUserByUsername(signInRequest.getEmail());
36.         var webToken = generationToken(user);
37.         var refreshToken = generationRefreshToken(new HashMap<>(), user);
38.
39.         JwtAuthenticationResponse jwtAuthenticationResponse = new JwtAuthenticationResponse();
40.         jwtAuthenticationResponse.setToken(webToken);
41.         jwtAuthenticationResponse.setRefreshToken(refreshToken);
42.         return jwtAuthenticationResponse;
43.     }
44.
45.
46.     @Override
47.     public String extractUserName(String token) {
48.         return extractClaim(token, Claims::getSubject);
49.     }
50.
51.     private boolean isTokenExpired(String token) {
52.         return extractClaim(token, Claims::getExpiration).before(new Date());
53.     }
54.
55.     private <T> T extractClaim(String token, Function<Claims, T> claimsResolvers) {
56.         final Claims claims = extractAllClaims(token);
57.         return claimsResolvers.apply(claims);
58.     }
59.
60.     private Claims extractAllClaims(String token) {
61.         return Jwts.parserBuilder().setSigningKey(getSigninKey()).build().parseClaimsJws(token).getBody();
62.     }
63.
64.     private Key getSigninKey() {
65.         byte[] key = Decoders.BASE64.decode(SECRET_KEY);
66.         return Keys.hmacShaKeyFor(key);
67.     }
68.
69.     @Override
70.     public boolean isTokenValid(String token, UserDetails userDetails) {
71.         String email = extractUserName(token);
72.         return (email.equals(userDetails.getUsername()) && !isTokenExpired(token));
73.     }
74.
75.     @Override
76.     public String generationToken(UserDetails userDetails) {
77.         return Jwts.builder().setSubject(userDetails.getUsername())
78.                 .setIssuedAt(new Date(System.currentTimeMillis()))
79.                 .setExpiration(new Date(System.currentTimeMillis() + TOKEN_EXPIRATION_TIME))
80.                 .signWith(getSigninKey(), SignatureAlgorithm.HS256)
81.                 .compact();
82.     }
83.
84.     @Override
85.     public String generationRefreshToken(Map<String, Object> extraClaims, UserDetails userDetails) {
86.         return Jwts.builder().setClaims(extraClaims).setSubject(userDetails.getUsername())
87.                 .setIssuedAt(new Date(System.currentTimeMillis()))
88.                 .setExpiration(new Date(System.currentTimeMillis() + REFRESH_TOKEN_EXPIRATION_TIME))
89.                 .signWith(getSigninKey(), SignatureAlgorithm.HS256)
90.                 .compact();
91.     }
92.
93.     @Override
94.     public JwtAuthenticationResponse refreshToken(RefreshTokenRequest refreshToken) {
95.         String email = extractUserName(refreshToken.getToken());
96.         UserDetails user = customUserDetailsServiceImpl.loadUserByUsername(email);
97.
98.         if (isTokenValid(refreshToken.getToken(), user)) {
99.             var webToken = generationToken(user);
100.
101.             JwtAuthenticationResponse jwtAuthenticationResponse = new JwtAuthenticationResponse();
102.
103.             jwtAuthenticationResponse.setToken(webToken);
104.             jwtAuthenticationResponse.setRefreshToken(refreshToken.getToken());
105.             return jwtAuthenticationResponse;
106.         }
107.         return null;
108.     }

ДОДАТОК Б
Графічні інтерфейси мобільної частини


Рисунок Б.5.1 – Інтерфейс головної сторінки
                                                                                          

Рисунок Б.5.2 – Інтерфейс списку готелів                                                                                          


Рисунок Б.5.3 – Інтерфейс історії оренди
                                                                                          

Рисунок Б.5.4 – Інтерфейс списку тварин                                                                                          


Рисунок Б.5.5 – Інтерфейс зворотнього зв’язку                                                                                          


